<!DOCTYPE html>
<html lang="pt">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Starlit Runway</title>
  <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/",
        "three/addons/stylized_coin.glb": "https://raw.githubusercontent.com/yourusername/yourrepo/main/assets/stylized_coin.glb"
      }
    }
  </script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #87CEEB;
      font-family: 'Arial', sans-serif;
    }

    #score,
    #lives {
      position: absolute;
      top: 10px;
      font-size: 20px;
      color: white;
      text-shadow: 1px 1px 2px black;
      display: none;
      /* Hide initially */
    }

    #score {
      right: 10px;
    }

    #lives {
      left: 10px;
    }

    #pause {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 40px;
      color: white;
      text-shadow: 2px 2px 4px black;
      z-index: 10;
      background: rgba(0, 0, 0, 0.3);
      padding: 30px 60px;
      border-radius: 20px;
      letter-spacing: 2px;
    }

    #pause-buttons {
      margin-top: 30px;
      display: flex;
      flex-direction: column;
      gap: 15px;
      align-items: center;
    }

    #pause-buttons button {
      font-size: 22px;
      padding: 10px 30px;
      border-radius: 10px;
      border: none;
      cursor: pointer;
    }

    /* Start Menu Styles */
    #menu-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 100;
      width: 80%;
      max-width: 800px;
    }

    #game-title {
      font-size: 48px;
      color: white;
      text-shadow: 0 0 10px #ff69b4, 0 0 20px #ff69b4, 0 0 30px #ff69b4;
      margin-bottom: 30px;
      letter-spacing: 3px;
    }

    #instructions {
      background: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 20px;
      border-radius: 15px;
      margin-bottom: 30px;
      text-align: left;
      box-shadow: 0 0 15px rgba(255, 105, 180, 0.7);
    }

    #instructions h2 {
      color: #ff69b4;
      text-align: center;
      margin-top: 0;
    }

    #instructions ul {
      list-style-type: none;
      padding-left: 10px;
    }

    #instructions li {
      margin-bottom: 10px;
      padding-left: 20px;
      position: relative;
    }

    #instructions li:before {
      position: absolute;
      left: 0;
      color: #ff69b4;
    }

    .control-key {
      display: inline-block;
      background: rgba(255, 255, 255, 0.2);
      padding: 2px 8px;
      border-radius: 4px;
      margin: 0 3px;
      font-family: monospace;
    }

    #start-button {
      background: linear-gradient(135deg, #ff69b4, #9370db);
      color: white;
      border: none;
      padding: 15px 40px;
      font-size: 24px;
      border-radius: 30px;
      cursor: pointer;
      box-shadow: 0 0 15px rgba(255, 105, 180, 0.7);
      transition: all 0.3s ease;
    }

    #start-button:hover {
      transform: scale(1.1);
      box-shadow: 0 0 25px rgba(255, 105, 180, 0.9);
    }

    .glow {
      animation: glow 2s infinite alternate;
    }

    @keyframes glow {
      from {
        text-shadow: 0 0 10px #ff69b4, 0 0 20px #ff69b4;
      }

      to {
        text-shadow: 0 0 20px #ff69b4, 0 0 30px #ff69b4, 0 0 40px #ff69b4;
      }
    }

    #gameover {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      z-index: 100;
      box-shadow: 0 0 30px rgba(255, 105, 180, 0.9);
      border: 2px solid #ff69b4;
      min-width: 300px;
    }

    #gameover h1 {
      font-size: 48px;
      margin-top: 0;
      color: #ff69b4;
      text-shadow: 0 0 10px #ff69b4;
    }

    #final-score {
      font-size: 28px;
      margin: 20px 0;
    }

    #gameover-buttons {
      margin-top: 30px;
      display: flex;
      flex-direction: column;
      gap: 15px;
      align-items: center;
    }

    #gameover-buttons button {
      font-size: 22px;
      padding: 10px 30px;
      border-radius: 10px;
      border: none;
      cursor: pointer;
      width: 200px;
      transition: all 0.3s ease;
    }

    #btn-restart-gameover {
      background: #ff69b4;
      color: white;
    }

    #btn-restart-gameover:hover {
      background: #ff4da6;
      transform: scale(1.05);
    }

    #btn-exit {
      background: #444;
      color: white;
    }

    #btn-exit:hover {
      background: #666;
      transform: scale(1.05);
    }

    /* Mobile controls */
    #mobile-controls {
      position: fixed;
      bottom: 20px;
      left: 0;
      width: 100%;
      display: none;
      /* Initially hidden, will show on mobile */
      justify-content: center;
      gap: 20px;
      z-index: 100;
    }

    .control-button {
      width: 60px;
      height: 60px;
      background: rgba(255, 105, 180, 0.7);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      color: white;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
      border: 2px solid rgba(255, 255, 255, 0.5);
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    }

    #btn-jump {
      width: 80px;
      height: 80px;
      font-size: 18px;
    }

    #btn-camera {
      position: fixed;
      top: 6%;
      right: 20px;
      width: 50px;
      height: 50px;
      font-size: 20px;
    }

    .control-button:active {
      transform: scale(0.9);
      background: rgba(255, 105, 180, 0.9);
    }

    @media (max-width: 768px) {
      #mobile-controls {
        display: flex;
      }

      /* Push score and lives indicators up on mobile */
      #score,
      #lives {
        top: 20px;
      }
    }
  </style>
</head>

<body>
  <!-- Mobile controls - add before closing body tag -->
  <div id="mobile-controls" style="display: none;">
    <div class="control-button" id="btn-left">‚Üê</div>
    <div class="control-button" id="btn-jump">Jump</div>
    <div class="control-button" id="btn-right">‚Üí</div>
    <div class="control-button" id="btn-camera">üé•</div>
  </div>

  <!-- Add the menu overlay -->
  <div id="menu-container">
    <h1 id="game-title" class="glow" style="margin-bottom: 20%;">Starlit Runway</h1>
    <div id="instructions">
      <h2>How to Play</h2>
      <ul>
        <li><span class="control-key">A</span> or <span class="control-key">‚Üê</span> - Move left</li>
        <li><span class="control-key">D</span> or <span class="control-key">‚Üí</span> - Move right</li>
        <li><span class="control-key">Space</span> - Jump</li>
        <li><span class="control-key">Ctrl</span> - Change camera view</li>
        <li><span class="control-key">Esc</span> - Pause game</li>
      </ul>
      <p>Collect coins for points and wing power-ups to fly!</p>
      <p>Avoid bombs or you'll lose a life!</p>
    </div>
    <button id="start-button">Start Adventure</button>
  </div>

  <!-- Game UI elements -->
  <div id="score">Score: 0</div>
  <div id="lives">Lives: 3</div>
  <div id="pause">
    PAUSED
    <div id="pause-buttons">
      <button id="btn-continue">Resume</button>
      <button id="btn-restart">Quit</button>
    </div>
  </div>

  <div id="gameover" style="display: none;">
    <h1>Game Over</h1>
    <div id="final-score">Final Score: 0</div>
    <div id="gameover-buttons">
      <button id="btn-restart-gameover">Play Again</button>
      <button id="btn-exit">Exit Game</button>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // Flag to check if game has started
    let gameStarted = false;

    // Get start button and add click handler
    document.getElementById('start-button').addEventListener('click', startGame);

    // Replace the existing startGame function
    function startGame() {
      // Start background music
      backgroundMusic.play().catch(error => {
        console.warn("Audio couldn't autoplay:", error);
        // Many browsers require user interaction before playing audio
      });

      // Start transition animation
      transitionToGame();
    }

    // Replace the transitionToGame function with this enhanced version
    function transitionToGame() {
      const transitionDuration = 2000; // 2 seconds for smoother animation
      const startTime = Date.now();

      // Initial and target positions/rotations
      const initialRotation = 165 * (Math.PI / 180); // Current menu fairy rotation (165 degrees)
      const targetRotation = Math.PI / 2; // Game fairy rotation (90 degrees)

      // Calculate rotation delta (we need to rotate -165 degrees + 90 degrees = -75 degrees)
      const rotationDelta = targetRotation - initialRotation;

      // Initial and target positions
      const initialPosition = new THREE.Vector3(0, -1, 0); // Current menu position
      const targetPosition = new THREE.Vector3(0, -2.3, 0); // Game start position

      function animateTransition() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / transitionDuration, 1);

        // Use easing for smoother animation
        const easeProgress = easeInOutCubic(progress);

        // Fade out the menu UI
        document.getElementById('menu-container').style.opacity = 1 - progress;

        if (menuCamera && menuFairy) {
          // Rotate the fairy smoothly from 165 degrees to 90 degrees
          menuFairy.rotation.y = initialRotation + rotationDelta * easeProgress;

          // Move fairy from menu position to game position
          const newX = initialPosition.x + (targetPosition.x - initialPosition.x) * easeProgress;
          const newY = initialPosition.y + (targetPosition.y - initialPosition.y) * easeProgress;
          const newZ = initialPosition.z + (targetPosition.z - initialPosition.z) * easeProgress;
          menuFairy.position.set(newX, newY, newZ);

          // Add a little bounce effect during transition
          if (progress < 0.7) {
            menuFairy.position.y += Math.sin(progress * Math.PI * 3) * 0.2 * (1 - progress);
          }

          // Camera follows fairy with zoom effect
          menuCamera.position.z = 5 - progress * 2;
          menuCamera.lookAt(menuFairy.position);

          // Update fairy animation
          if (menuMixer) {
            menuMixer.update(0.016);
          }

          // Create sparkle trail effect during rotation
          if (progress < 0.8 && Math.random() > 0.8) {
            const sparkle = new THREE.Sprite(
              new THREE.SpriteMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
              })
            );
            sparkle.scale.set(0.1, 0.1, 0.1);
            sparkle.position.copy(menuFairy.position);
            sparkle.position.x += (Math.random() - 0.5) * 0.3;
            sparkle.position.y += (Math.random() - 0.5) * 0.3;
            sparkle.position.z += (Math.random() - 0.5) * 0.3;
            menuScene.add(sparkle);

            // Fade out sparkle
            setTimeout(() => {
              const startFade = Date.now();
              const fadeDuration = 500;

              function fadeSparkle() {
                const fadeElapsed = Date.now() - startFade;
                const fadeProgress = Math.min(fadeElapsed / fadeDuration, 1);

                sparkle.material.opacity = 0.8 * (1 - fadeProgress);
                sparkle.scale.multiplyScalar(1.01);

                if (fadeProgress < 1) {
                  requestAnimationFrame(fadeSparkle);
                } else {
                  menuScene.remove(sparkle);
                }
              }
              fadeSparkle();
            }, 100);
          }

          // Render menu scene with transition effects
          menuRenderer.render(menuScene, menuCamera);
        }

        if (progress < 1) {
          requestAnimationFrame(animateTransition);
        } else {
          completeTransition();
        }
      }

      // Easing function for smoother animation
      function easeInOutCubic(x) {
        return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
      }

      // Start the transition animation
      animateTransition();

      // Replace the completeTransition function with this improved version 
      function completeTransition() {
        // Stop and clear menu animations
        if (menuMixer) {
          menuMixer.stopAllAction();
          menuMixer.uncacheRoot(menuFairy);
          menuMixer = null;
        }

        // Stop all menu animations
        if (menuIdleAction) {
          menuIdleAction.stop();
          menuIdleAction = null;
        }

        // Clean up menu scene objects
        if (menuScene) {
          // Properly dispose fireflies
          if (menuFireflies) {
            menuFireflies.children.forEach(firefly => {
              if (firefly.material) {
                firefly.material.dispose();
              }
            });
            menuScene.remove(menuFireflies);
          }

          // Dispose menu trees
          menuTrees.forEach(tree => {
            resourceManager.disposeObject(tree);
          });
          menuTrees = [];

          // Dispose fairy model
          if (menuFairy) {
            resourceManager.disposeObject(menuFairy);
            menuFairy = null;
          }

          // Clear the scene from memory
          menuScene.clear();
          menuScene = null;
        }

        // Remove menu renderer from DOM
        if (menuRenderer) {
          if (menuRenderer.domElement && menuRenderer.domElement.parentNode) {
            menuRenderer.domElement.parentNode.removeChild(menuRenderer.domElement);
          }
          menuRenderer.dispose();
          menuRenderer = null;
        }

        // Clear references to the menu camera
        menuCamera = null;

        // Hide menu UI
        document.getElementById('menu-container').style.display = 'none';

        // Show game UI
        document.getElementById('score').style.display = 'block';
        document.getElementById('lives').style.display = 'block';

        // If player model is already loaded, make sure it's at correct position/rotation
        if (playerModel) {
          playerModel.position.set(0, -2.3, 0);
          playerModel.rotation.y = Math.PI / 2;
          playerModel.visible = true;
        }


        // Spawn initial objects before game starts
        for (let i = 0; i < 5; i++) {
          // Calculate staggered z positions from -5 to -25
          const z = -5 - (i * 5);

          // Add coins
          if (i % 2 === 0) {
            const coinX = (Math.random() - 0.5) * (LIMITE_ESTRADA * 1.5);
            spawnCoin(coinX, -2.3, z);
          }

          // Add a power-up
          if (i === 2) {
            const powerX = (Math.random() - 0.5) * (LIMITE_ESTRADA * 1.5);
            spawnPowerUp(powerX, -2.3, z - 2);
          }
        }
        // Start the game
        gameStarted = true;



        // Hint to the browser to perform garbage collection
        if (window.gc) {
          window.gc();
        }

        // Start the game animation loop
        animate();
      }
    }

    // Add CSS transition to menu container
    document.getElementById('menu-container').style.transition = 'opacity 1s ease';

    let gravityInverted = false;
    let isFlying = false;
    let flyStartTime = 0;
    const FLY_DURATION = 5000; // 5 segundos em ms

    // Par√¢metros para ciclo dia-noite
    const dayNightDuration = 60 * 1000; // 1 minuto em ms
    let dayNightStart = Date.now() - (dayNightDuration * 0.125);

    const dayColors = {
      skyTop: new THREE.Color('#ffd6f6'),
      skyBottom: new THREE.Color('#b8c4ff'),
      fog: new THREE.Color('#c6b9ff'),
      sun: new THREE.Color('#FFD700'),
      ambient: 0.2
    };

    const nightColors = {
      skyTop: new THREE.Color('#0a0a2a'),
      skyBottom: new THREE.Color('#1a1a40'),
      fog: new THREE.Color('#222244'),
      sun: new THREE.Color('#444466'),
      ambient: 0.08
    };

    const textureLoader = new THREE.TextureLoader();
    const barkTexture = textureLoader.load('https://threejs.org/examples/textures/tree/bark.jpg');

    const coinSound = new Audio('assets/audio/coin-get.ogg');
    coinSound.volume = 0.5; // Adjust volume as needed

    const wingSound = new Audio('assets/audio/wing_powerup.wav');
    wingSound.volume = 0.5; // Adjust volume as needed

    const bombSound = new Audio('assets/audio/damage.wav');
    bombSound.volume = 0.5; // Adjust volume as needed

    // Add this code right after the other audio declarations (around line 541)
    // Background music
    const backgroundMusic = new Audio('assets/audio/2019-05-17_-_In_The_Clouds_-_David_Fesliyan.mp3');
    backgroundMusic.loop = true;
    backgroundMusic.volume = 0.4; // Set to 40% volume so it doesn't overpower sound effects

    const scene = new THREE.Scene();

    const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
    const skyMaterial = new THREE.ShaderMaterial({
      uniforms: {
        topColor: { value: new THREE.Color('#ffd6f6') },
        bottomColor: { value: new THREE.Color('#b8c4ff') },
      },
      vertexShader: `
      varying vec3 vWorldPosition;
      void main() {
        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
        vWorldPosition = worldPosition.xyz;
        gl_Position = projectionMatrix * viewMatrix * worldPosition;
      }
    `,
      fragmentShader: `
      uniform vec3 topColor;
      uniform vec3 bottomColor;
      varying vec3 vWorldPosition;
      void main() {
        float height = normalize(vWorldPosition).y;
        gl_FragColor = vec4(mix(bottomColor, topColor, max(height, 0.0)), 1.0);
      }
    `,
      side: THREE.BackSide,
    });
    const sky = new THREE.Mesh(skyGeometry, skyMaterial);
    scene.add(sky);

    scene.fog = new THREE.Fog('#c6b9ff', 5, 25);

    // -------- SISTEMA DE C√ÇMARAS --------
    // 0: 1¬™ pessoa, 1: 3¬™ pessoa normal, 2: 3¬™ pessoa afastada
    const camera1st = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const camera3rd = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const cameraFar = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    let cameraMode = 1; // come√ßa em 3¬™ pessoa normal

    // Atualiza o tamanho das c√¢maras se o ecr√£ mudar
    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.shadowMap.enabled = true;
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    window.addEventListener('resize', () => {
      [camera1st, camera3rd, cameraFar].forEach(cam => {
        cam.aspect = window.innerWidth / window.innerHeight;
        cam.updateProjectionMatrix();
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --------- CONTROLOS ORBIT (apenas para debug, n√£o afeta c√¢maras do jogo) ---------
    // new OrbitControls(camera3rd, renderer.domElement);

    class Box extends THREE.Mesh {
      constructor({ width, height, depth, color = '#00ff00', velocity = { x: 0, y: 0, z: 0 }, position = { x: 0, y: 0, z: 0 }, zAcceleration = false }) {
        super(new THREE.BoxGeometry(width, height, depth), new THREE.MeshStandardMaterial({ color }));
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.position.set(position.x, position.y, position.z);
        this.velocity = velocity;
        this.gravity = -0.005;
        this.zAcceleration = zAcceleration;
        this.isOnGround = false;
        this.castShadow = true;
        this.receiveShadow = true;
        this.updateSides();
      }

      updateSides() {
        this.right = this.position.x + this.width / 2;
        this.left = this.position.x - this.width / 2;
        this.bottom = this.position.y - this.height / 2;
        this.top = this.position.y + this.height / 2;
        this.front = this.position.z + this.depth / 2;
        this.back = this.position.z - this.depth / 2;
      }

      update(ground) {
        this.updateSides();
        if (this.zAcceleration) this.velocity.z += 0.001;
        this.position.x += this.velocity.x;
        this.position.z += this.velocity.z;
        this.applyGravity(ground);
      }

      applyGravity(ground) {
        this.velocity.y += this.gravity;
        this.position.y += this.velocity.y;

        const groundTop = ground.position.y + 0.01;
        if (!gravityInverted) {
          if (this.position.y - this.height / 2 <= groundTop) {
            this.position.y = groundTop + this.height / 2;
            this.velocity.y = 0;
            this.isOnGround = true;
          } else {
            this.isOnGround = false;
          }
        } else {
          const ceiling = groundTop + 5;
          if (this.position.y + this.height / 2 >= ceiling) {
            this.position.y = ceiling - this.height / 2;
            this.velocity.y = 0;
            this.isOnGround = true;
          } else {
            this.isOnGround = false;
          }
        }
      }
    }

    function boxCollision({ box1, box2 }) {
      const x = box1.right >= box2.left && box1.left <= box2.right;
      const y = box1.bottom <= box2.top && box1.top >= box2.bottom;
      const z = box1.front >= box2.back && box1.back <= box2.front;
      return x && y && z;
    }

    // Limite lateral da estrada (para n√£o passar para cima das luzes)
    const LIMITE_ESTRADA = 3;

    // Cubo fica parado em z, cen√°rio move-se para tr√°s
    const cube = new Box({
      width: 1,
      height: 1,
      depth: 1,
      velocity: { x: 0, y: -0.01, z: 0 },
      color: '#33cc33'
    });
    cube.visible = false;
    scene.add(cube);

    // Defini√ß√µes para velocidade baseada na pontua√ß√£o
    const SPEED_SCORE_STEP = 30;         // A cada 30 pontos, aumenta a velocidade
    const BASE_FORWARD_SPEED = 0.045;    // velocidade inicial
    const MAX_FORWARD_SPEED = 0.18;      // velocidade m√°xima
    const SPEED_INCREMENT = 0.012;       // quanto aumenta por cada STEP de score

    let forwardSpeed = BASE_FORWARD_SPEED; // inicializa com a velocidade base

    const runwayLength = 100;

    // Estrada amarela e linha central: v√°rias pe√ßas para nunca desaparecerem
    const numSegments = 4;
    const carpets = [];
    const centerLines = [];
    for (let i = 0; i < numSegments; i++) {
      const segLength = runwayLength / numSegments;
      const carpet = new THREE.Mesh(
        new THREE.BoxGeometry(7.5, 0.1, segLength),
        new THREE.MeshStandardMaterial({ color: '#DAA520' })
      );
      carpet.position.set(0, -2.45, -runwayLength / 2 + i * segLength + segLength / 2);
      carpet.castShadow = true;
      scene.add(carpet);
      carpets.push(carpet);

      const centerLine = new THREE.Mesh(
        new THREE.BoxGeometry(6.5, 0.11, segLength),
        new THREE.MeshStandardMaterial({ color: '#FFD700' })
      );
      centerLine.position.set(0, -2.44, -runwayLength / 2 + i * segLength + segLength / 2);
      centerLine.receiveShadow = true;
      scene.add(centerLine);
      centerLines.push(centerLine);
    }

    const ground = new THREE.Mesh(
      new THREE.CircleGeometry(30, 64),
      new THREE.MeshStandardMaterial({
        color: '#30503A',
        side: THREE.DoubleSide
      })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.set(0, -2.5, 0);
    ground.receiveShadow = true;
    ground.castShadow = true;
    scene.add(ground);

    const lightGroup = new THREE.Group();
    const lightMaterial = new THREE.MeshStandardMaterial({ color: '#ffffff' });
    const lateralLights = []; // <-- Guarda as luzes para controlar depois

    for (let i = 0; i < 50; i++) {
      const zPosition = -runwayLength / 2 + (i / 49) * runwayLength;
      const lightLeft = new THREE.Mesh(new THREE.SphereGeometry(0.1, 16, 16), lightMaterial);
      const lightRight = lightLeft.clone();
      lightLeft.position.set(-3.5, -2.4, zPosition);
      lightRight.position.set(3.5, -2.4, zPosition);
      lightGroup.add(lightLeft);
      lightGroup.add(lightRight);

      // Adiciona PointLight em cada esfera
      const pointLightLeft = new THREE.PointLight(0xffffff, 1.2, 3); // intensidade 0 (apagada de dia)
      pointLightLeft.position.copy(lightLeft.position);
      scene.add(pointLightLeft);
      lateralLights.push(pointLightLeft);

      const pointLightRight = new THREE.PointLight(0xffffff, 1.2, 3);
      pointLightRight.position.copy(lightRight.position);
      scene.add(pointLightRight);
      lateralLights.push(pointLightRight);
    }
    scene.add(lightGroup);

    // Guardar √°rvores para mover depois
    const trees = [];
    function adicionarArvores(qtd = 100) {
      const raioChao = 25;
      const larguraCaminho = 8;
      for (let i = 0; i < qtd; i++) {
        const troncoAltura = 1 + Math.random() * 0.3;
        const tronco = new THREE.Mesh(
          new THREE.CylinderGeometry(0.08, 0.08, troncoAltura),
          new THREE.MeshStandardMaterial({ map: barkTexture })
        );
        tronco.castShadow = true;
        tronco.receiveShadow = true;

        const coneMaterial = new THREE.MeshStandardMaterial({ color: '#228B22' });
        const cones = [];
        for (let j = 0; j < 3; j++) {
          const cone = new THREE.Mesh(
            new THREE.ConeGeometry(0.6 - j * 0.15, 0.7, 8),
            coneMaterial
          );
          cone.castShadow = true;
          cone.receiveShadow = true;
          cones.push(cone);
        }

        let x, z;
        do {
          const angulo = Math.random() * Math.PI * 2;
          const distancia = Math.random() * raioChao;
          x = Math.cos(angulo) * distancia;
          z = Math.sin(angulo) * distancia;
        } while (z > 4 || (x > -larguraCaminho / 2 && x < larguraCaminho / 2));

        // Distribuir √°rvores ao longo da pista
        z = -runwayLength / 2 + Math.random() * runwayLength;

        const y = -2.5;
        const topoTroncoY = y + troncoAltura / 2;
        tronco.position.set(x, topoTroncoY, z);
        scene.add(tronco);
        trees.push(tronco);
        cones.forEach((cone, idx) => {
          const heightSoFar = topoTroncoY + 0.6 + idx * 0.5;
          cone.position.set(x, heightSoFar, z);
          scene.add(cone);
          trees.push(cone);
        });
      }
    }

    adicionarArvores();

    // Carrega as texturas do sol e da lua
    const sunTexture = textureLoader.load('assets/textures/sun.png');
    const moonTexture = textureLoader.load('assets/textures/moon.png');

    // Cria o mesh do sol (que tamb√©m ser√° a lua)
    const sun = new THREE.Mesh(
      new THREE.SphereGeometry(2, 32, 32),
      new THREE.MeshBasicMaterial({
        map: sunTexture,
        emissive: 0xffff80,
        emissiveIntensity: 1.0
      })
    );
    sun.position.set(10, 5, -10);
    sun.castShadow = false;
    scene.add(sun);
    sun.material.map = sunTexture;
    sun.material.needsUpdate = true;

    // Add a point light that will follow the sun
    const sunPointLight = new THREE.PointLight(0xffffcc, 1.5, 50);
    sunPointLight.position.copy(sun.position);
    scene.add(sunPointLight);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.45); // Mais luz ambiente
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xffffff, 0.55); // Menos intensidade e cor neutra
    sunLight.position.set(10, 20, -10);
    sunLight.castShadow = true;

    // Add this after the sun light creation (around line 544)
    // Improve shadow quality for the main scene
    sunLight.shadow.mapSize.width = 2048;  // Higher resolution shadow map
    sunLight.shadow.mapSize.height = 2048;
    sunLight.shadow.camera.near = 0.1;
    sunLight.shadow.camera.far = 100;

    // Set up proper shadow camera frustum to contain all trees
    sunLight.shadow.camera.left = -30;
    sunLight.shadow.camera.right = 30;
    sunLight.shadow.camera.top = 30;
    sunLight.shadow.camera.bottom = -30;
    sunLight.shadow.bias = -0.0005;
    scene.add(sunLight);


    const fireflies = new THREE.Group();
    const fireflyTexture = new THREE.SpriteMaterial({ color: '#ccffcc' });
    for (let i = 0; i < 60; i++) {
      const sprite = new THREE.Sprite(fireflyTexture.clone());
      sprite.scale.set(0.2, 0.2, 0.2);
      sprite.position.set((Math.random() - 0.5) * 40, 0.5 + Math.random() * 4, -Math.random() * 20);
      fireflies.add(sprite);
    }
    scene.add(fireflies);

    const keys = { a: false, d: false, arrowleft: false, arrowright: false };

    let paused = false;

    // Bot√µes de pausa
    const pauseDiv = document.getElementById('pause');
    const btnContinue = document.getElementById('btn-continue');
    const btnRestart = document.getElementById('btn-restart');

    btnContinue.addEventListener('click', () => {
      paused = false;
      pauseDiv.style.display = 'none';
      animate();
    });

    btnRestart.addEventListener('click', () => {
      window.location.reload();
    });

    // Game Over buttons
    const gameoverDiv = document.getElementById('gameover');
    const btnRestartGameover = document.getElementById('btn-restart-gameover');
    const btnExit = document.getElementById('btn-exit');
    const finalScoreEl = document.getElementById('final-score');

    btnRestartGameover.addEventListener('click', () => {
      restartGame();  // Use our new function instead of reloading page
    });

    btnExit.addEventListener('click', () => {
      returnToMainMenu();
    });

    // Add this new function to handle returning to the main menu
    function returnToMainMenu() {
      // Hide game over screen
      gameoverDiv.style.display = 'none';

      // Reset game state
      score = 0;
      lives = 3;
      updateScore();
      updateLives();

      // Hide game UI
      document.getElementById('score').style.display = 'none';
      document.getElementById('lives').style.display = 'none';

      // Reset player position
      cube.position.set(0, -2.3, 0);
      cube.velocity.y = -0.01;
      cube.gravity = -0.005;
      gravityInverted = false;
      isFlying = false;

      // Clear all enemies
      while (enemies.length > 0) {
        const enemy = enemies.pop();
        scene.remove(enemy);
      }

      // Reset player model
      if (playerModel) {
        playerModel.visible = false;
      }

      // Reset game flags
      gameStarted = false;
      paused = false;

      // Re-initialize menu scene
      if (!menuScene) {
        setupMenuScene();
      } else {
        // Just make sure the menu renderer is added back if needed
        if (!document.body.contains(menuRenderer.domElement)) {
          document.body.insertBefore(menuRenderer.domElement, document.body.firstChild);
        }
      }

      // Show menu container
      document.getElementById('menu-container').style.display = 'block';
      document.getElementById('menu-container').style.opacity = '1';

      // Restart menu animation
      animateMenu();
    }

    // Create a function to show the game over screen
    function showGameOver() {
      paused = true;
      gameoverDiv.style.display = 'block';
      finalScoreEl.textContent = `Final Score: ${score}`;

      // Lower music volume during game over
      backgroundMusic.volume = 0.2;

      // Stop all animations and sounds
      if (mixer) {
        mixer.stopAllAction();
      }
      if (coinSound) {
        coinSound.pause();
      }
      if (wingSound) {
        wingSound.pause();
      }
      if (bombSound) {
        bombSound.pause();
      }
    }

    // Add this new function to restart the game immediately
    function restartGame() {
      // Hide game over screen
      gameoverDiv.style.display = 'none';

      // Reset music volume
      backgroundMusic.volume = 0.4;

      // Make sure music is playing
      if (backgroundMusic.paused) {
        backgroundMusic.play().catch(e => console.warn("Couldn't restart audio:", e));
      }

      // Reset game state
      score = 0;
      lives = 3;
      updateScore();
      updateLives();

      // Reset player position and state
      cube.position.set(0, -2.3, 0);
      cube.velocity.y = -0.01;
      cube.gravity = -0.005; // Make sure gravity is correct
      gravityInverted = false;
      isFlying = false;
      flyStartTime = 0;
      flyingCoinsGenerated = false;

      // Clear all enemies
      while (enemies.length > 0) {
        const enemy = enemies.pop();
        scene.remove(enemy);
      }

      // Reset spawn values
      spawnCooldown = 100;
      spawnTimer = 0;

      // Reset player model
      if (playerModel) {
        playerModel.position.copy(cube.position);
        playerModel.position.y = -2.7; // Correct height on ground
        playerModel.rotation.y = Math.PI / 2; // Facing direction of travel
        playerModel.rotation.z = 0;
        playerModel.visible = true;
      }

      // Reset animations
      if (mixer) {
        mixer.stopAllAction();
        if (idleAction) {
          idleAction.reset().play();
        }
      }

      // Unpause and restart animation
      paused = false;
      gameStarted = true;
      animate();
    }

    window.addEventListener('keydown', e => {
      // PAUSE/UNPAUSE com ESC
      if (e.code === 'Escape' && !e.repeat) {
        paused = !paused;
        pauseDiv.style.display = paused ? 'block' : 'none';

        // Pause/resume music based on game state
        if (paused) {
          backgroundMusic.pause();
        } else {
          backgroundMusic.play().catch(e => console.warn("Couldn't resume audio:", e));
          animate(); // retoma anima√ß√£o se despausar
        }
        return;
      }

      if (paused) return; // n√£o processa outros controlos se pausado

      keys[e.key.toLowerCase()] = true;

      if (e.code === 'Space' && cube.isOnGround) {
        cube.velocity.y = gravityInverted ? -0.12 : 0.12;
        cube.isOnGround = false;
      }

      // Troca de c√¢mara com Ctrl (n√£o repete se mantiver pressionado)
      if (e.ctrlKey && !e.repeat) {
        cameraMode = (cameraMode + 1) % 3;
      }
    });

    window.addEventListener('keyup', e => {
      if (paused) return;
      keys[e.key.toLowerCase()] = false;
    });

    const enemies = [];
    let spawnCooldown = 80;
    let spawnTimer = 0;
    let score = 0;
    let lives = 3;

    function updateScore() {
      document.getElementById('score').innerText = `Pontua√ß√£o: ${score}`;
    }

    function updateLives() {
      document.getElementById('lives').innerText = `Vidas: ${lives}`;
    }

    // --- PLAYER MODEL LOADING ---
    let playerModel = null;
    let mixer = null;
    let swimAction = null;
    let idleAction = null;
    let takeDamage = null; // Nova vari√°vel para a anima√ß√£o idle/padr√£o

    const playerLoader = new GLTFLoader();
    playerLoader.load(
      'assets/models/flora_sirenix.glb', // Caminho para o modelo
      gltf => {
        playerModel = gltf.scene;
        playerModel.scale.set(0.5, 0.5, 0.5); // Ajusta a escala do modelo
        playerModel.position.set(0, -2.3, 0); // Ajusta a posi√ß√£o inicial para que fique no ch√£o
        playerModel.rotation.y = Math.PI / 2; // Roda 90 graus no eixo Y
        playerModel.castShadow = true;
        playerModel.receiveShadow = true;
        scene.add(playerModel);

        // Configurar o mixer de anima√ß√µes
        mixer = new THREE.AnimationMixer(playerModel);

        // Verificar as anima√ß√µes dispon√≠veis
        if (gltf.animations && gltf.animations.length > 0) {
          console.log("Anima√ß√µes dispon√≠veis:", gltf.animations.map(a => a.name));

          // Procurar pela anima√ß√£o "idle" (padr√£o) e "swim"
          const idleClip = gltf.animations.find(anim =>
            anim.name.toLowerCase().includes("idle")
          );

          const swimClip = gltf.animations.find(anim =>
            anim.name.toLowerCase().includes("swim")
          );

          const takeDamageClip = gltf.animations.find(anim =>
            anim.name.toLowerCase().includes("take damage")
          );

          if (idleClip) {
            idleAction = mixer.clipAction(idleClip);
            idleAction.play(); // Inicia com a anima√ß√£o padr√£o
            console.log("Anima√ß√£o idle ativada");
          }

          if (swimClip) {
            swimAction = mixer.clipAction(swimClip);
            // N√£o inicia a anima√ß√£o swim agora
          } else if (idleClip) {
            // Se n√£o encontrar swim, duplica idle para usar como swim
            swimAction = mixer.clipAction(idleClip);
          }

          if (takeDamageClip) {
            takeDamage = mixer.clipAction(takeDamageClip);
          } else {
            console.warn("Anima√ß√£o de dano n√£o encontrada, usando anima√ß√£o idle como fallback.");
          }
        }
      },
      undefined,
      err => {
        console.error('Erro ao carregar o modelo do player:', err);
      }
    );

    // --- COIN MODEL LOADING ---
    let coinGLTF = null;
    const coinLoader = new GLTFLoader();
    coinLoader.load(
      'assets/models/stylized_coin.glb', // Agora o modelo est√° em assets/models/
      gltf => { coinGLTF = gltf.scene; },
      undefined,
      err => { console.error('Erro ao carregar a moeda:', err); }
    );

    // --- WING MODEL LOADING ---
    let wingGLTF = null;
    const wingLoader = new GLTFLoader();
    wingLoader.load(
      'assets/models/wings.glb',
      gltf => { wingGLTF = gltf.scene; },
      undefined,
      err => { console.error('Erro ao carregar a asa:', err); }
    );

    // --- BOMB MODEL LOADING ---
    let bombGLTF = null;
    const bombLoader = new GLTFLoader();
    bombLoader.load(
      'assets/models/bomb.glb', // Caminho para o modelo da bomba
      gltf => { bombGLTF = gltf.scene; },
      undefined,
      err => { console.error('Erro ao carregar o modelo da bomba:', err); }
    );

    // Fun√ß√£o para criar uma bomba
    function spawnBomb(x, y, z) {
      if (bombGLTF) {
        const bomb = bombGLTF.clone(true);
        bomb.position.set(x, -2.1, z);
        bomb.scale.set(0.15, 0.15, 0.15); // Ajusta a escala da bomba

        bomb.castShadow = true;
        bomb.userData = { type: 'bomb' };
        scene.add(bomb);
        enemies.push(bomb);
        return bomb;
      } else {
        console.error('Modelo da bomba ainda n√£o carregado.');
      }
    }

    // --- MUSHROOM HOUSE MODEL LOADING ---
    let mushroomHouseGLTF = null;
    const mushroomHouseLoader = new GLTFLoader();
    mushroomHouseLoader.load(
      'assets/models/mushroom_house.glb', // Caminho para o modelo
      gltf => {
        mushroomHouseGLTF = gltf.scene;
        // Adicionar casas de cogumelo ao cen√°rio
        addMushroomHouses();
      },
      undefined,
      err => { console.error('Erro ao carregar a casa de cogumelo:', err); }
    );

    // Array para armazenar as casas de cogumelo
    const mushroomHouses = [];

    // Fun√ß√£o para adicionar casas de cogumelo no cen√°rio
    function addMushroomHouses() {
      if (!mushroomHouseGLTF) return;

      // Avalia m√∫ltiplas posi√ß√µes potenciais e aplica chance baixa de spawn
      const possiblePositions = 10;  // N√∫mero de posi√ß√µes potenciais avaliadas
      const spawnChance = 0.15;     // Apenas 15% de chance de aparecer uma casa em cada posi√ß√£o

      for (let i = 0; i < possiblePositions; i++) {
        // Aplica chance de spawn
        if (Math.random() > spawnChance) continue;

        const house = mushroomHouseGLTF.clone();

        // Mant√©m a escala de 30 como solicitado
        house.scale.set(30, 30, 30);

        // Aleat√≥rio se est√° √† esquerda (70%) ou direita (30%) - tornando assim√©trico
        const isLeftSide = Math.random() < 0.7;

        // Posi√ß√£o X com varia√ß√£o
        let x;
        if (isLeftSide) {
          // Lado esquerdo com varia√ß√£o
          x = -7 - Math.random() * 13; // Entre -7 e -15
        } else {
          // Lado direito com varia√ß√£o
          x = 7 + Math.random() * 13;  // Entre 7 e 15
        }

        // Posi√ß√µes Z aleat√≥rias ao longo do caminho
        // Usa posi√ß√µes mais variadas, n√£o apenas 4 grupos fixos
        const z = -25 - Math.random() * 10; // Entre -25 e -35

        house.position.set(
          x,
          -2.5, // Altura fixa no ch√£o 
          z
        );

        // Rota√ß√£o com maior aleatoriedade
        // Base: viradas para estrada, mas com mais varia√ß√£o
        const baseAngle = isLeftSide ? Math.PI / 4 : -Math.PI / 4;
        // Varia√ß√£o de ¬±30 graus
        const randomAngle = (Math.random() - 0.5) * Math.PI / 3;
        house.rotation.y = baseAngle + randomAngle;

        house.castShadow = true;
        house.receiveShadow = true;

        scene.add(house);
        mushroomHouses.push(house);
      }
    }

    let flyingCoinsGenerated = false;
    let flyingCoins = [];

    // Fun√ß√£o para verificar se j√° existe uma moeda ou asa perto da posi√ß√£o (x, z)
    function isOccupied(x, z, type) {
      // Safety check for empty array
      if (!enemies || enemies.length === 0) return false;

      // Reduced minimum distance for less collision detection
      const minDistance = 1.0; // Reduced from 1.5

      return enemies.some(obj => {
        // Skip invalid objects
        if (!obj || !obj.position) return false;

        // For coins specifically, be more lenient with placement
        if (type === 'coin') {
          // Only consider bombs as blockers for coins
          if (!obj.userData || obj.userData.type !== 'bomb') {
            return false;
          }
        }

        // Calculate distance
        const dx = obj.position.x - x;
        const dz = obj.position.z - z;
        const distance = Math.sqrt(dx * dx + dz * dz);

        // Return true if too close (less than minimum distance)
        return distance < minDistance;
      });
    }

    function spawnPowerUp(x, y, z) {
      // N√£o cria se j√° houver moeda perto
      if (isOccupied(x, z, 'flyPower')) return;

      if (wingGLTF) {
        const wing = wingGLTF.clone(true);
        wing.scale.set(0.25, 0.25, 0.25);
        wing.position.set(x, -1.5, z);

        // Altera a cor de todos os meshes para #ffccff
        wing.traverse(child => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
            if (!child.material) {
              child.material = new THREE.MeshStandardMaterial({ color: 0xffccff });
            } else {
              child.material.color.set('#ffccff');
            }
            child.material.transparent = false;
            child.material.opacity = 1;
          }
        });

        wing.userData = { type: 'flyPower' };
        scene.add(wing);
        enemies.push(wing);
        console.log('Asa adicionada em', x, y, z);
      } else {
        const powerUp = new Box({
          width: 1.2,
          height: 1.2,
          depth: 1.2,
          position: { x, y, z },
          color: '#00e6ff',
          zAcceleration: true
        });
        powerUp.userData = { type: 'flyPower' };
        powerUp.castShadow = true;
        scene.add(powerUp);
        enemies.push(powerUp);
      }
    }


    // --- Ao criar moedas, n√£o cria se j√° houver asa perto ---
    function spawnCoin(x, y, z) {
      // Simplified collision check
      if (isOccupied(x, z, 'coin')) {
        return null;
      }

      let coin;

      // Make sure we create a proper coin
      if (coinGLTF) {
        // Create using the model - fixed cloning method
        try {
          // Try different possible ways the model might be structured
          if (coinGLTF.scene) {
            coin = coinGLTF.scene.clone();
          } else if (typeof coinGLTF.clone === 'function') {
            coin = coinGLTF.clone();
          } else {
            throw new Error('Invalid coin model structure');
          }

          coin.position.set(x, y, z);
          coin.scale.set(1.2, 1.2, 1.2);
        } catch (error) {
          console.warn('Error cloning coin model, falling back to box', error);
          // Fall back to box if cloning fails
          coin = new Box({
            width: 1,
            height: 1,
            depth: 1,
            position: { x, y, z },
            color: '#FFD700',
            zAcceleration: true
          });
        }
      }
      else {
        // Fallback to simple box
        coin = new Box({
          width: 1,
          height: 1,
          depth: 1,
          position: { x, y, z },
          color: '#FFD700',
          zAcceleration: true
        });
      }

      // Make sure the type is set properly
      if (!coin.userData) coin.userData = {};
      coin.userData.type = 'coin';

      // Add to scene and tracking
      scene.add(coin);
      enemies.push(coin);
      return coin;
    }

    // Also add an event listener for page unload to clean up resources
    window.addEventListener('beforeunload', function () {
      // Perform final cleanup
      resourceManager.disposeAll();
      objectPools.clearPools();

      // Clear audio resources
      if (backgroundMusic) {
        backgroundMusic.pause();
        backgroundMusic.src = '';
      }
      if (coinSound) {
        coinSound.pause();
        coinSound.src = '';
      }
      if (wingSound) {
        wingSound.pause();
        wingSound.src = '';
      }
      if (bombSound) {
        bombSound.pause();
        bombSound.src = '';
      }

      // Clear large objects
      scene = null;
      renderer.dispose();
    });

    let lastCoinSpawnZ = -10;

    // Add this just before the animate function call (around line 2365)

    // Check if device is mobile
    function isMobileDevice() {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
        (window.innerWidth <= 768);
    }

    // Setup mobile controls
    function setupMobileControls() {
      const mobileControls = document.getElementById('mobile-controls');

      if (isMobileDevice()) {
        mobileControls.style.display = 'flex';

        // Left button
        const btnLeft = document.getElementById('btn-left');
        btnLeft.addEventListener('touchstart', () => { keys.a = true; keys.arrowleft = true; });
        btnLeft.addEventListener('touchend', () => { keys.a = false; keys.arrowleft = false; });

        // Right button
        const btnRight = document.getElementById('btn-right');
        btnRight.addEventListener('touchstart', () => { keys.d = true; keys.arrowright = true; });
        btnRight.addEventListener('touchend', () => { keys.d = false; keys.arrowright = false; });

        // Jump button
        const btnJump = document.getElementById('btn-jump');
        btnJump.addEventListener('touchstart', () => {
          if (cube.isOnGround) {
            cube.velocity.y = gravityInverted ? -0.12 : 0.12;
            cube.isOnGround = false;
          }
        });

        // Camera button
        const btnCamera = document.getElementById('btn-camera');
        btnCamera.addEventListener('touchstart', () => {
          cameraMode = (cameraMode + 1) % 3;
        });
      }
    }

    // Initialize mobile controls when game starts
    document.addEventListener('DOMContentLoaded', () => {
      setupMobileControls();
    });

    function animate() {
      if (paused || !gameStarted) return;

      // Desativa voo automaticamente ap√≥s 5 segundos
      if (isFlying && Date.now() - flyStartTime > FLY_DURATION) {
        gravityInverted = !gravityInverted;
        cube.gravity *= -1;
        cube.velocity.y = gravityInverted ? 0.12 : -0.12;
        cube.rotation.z = gravityInverted ? Math.PI : 0;
        isFlying = false;
      }

      mushroomHouses.forEach(house => {
        house.position.z += forwardSpeed;
        if (house.position.z > runwayLength / 2) {
          house.position.z -= runwayLength;
          // Randomiza um pouco a posi√ß√£o X e rota√ß√£o Y quando recicla
          const side = house.position.x < 0 ? -1 : 1;
          house.position.x = side * (5 + Math.random() * 2);
          house.rotation.y = Math.random() * Math.PI * 2;
        }
      });

      requestAnimationFrame(animate);

      // Calcula a velocidade baseada na pontua√ß√£o
      let speedLevel = Math.floor(score / SPEED_SCORE_STEP);
      forwardSpeed = BASE_FORWARD_SPEED + speedLevel * SPEED_INCREMENT;
      if (forwardSpeed > MAX_FORWARD_SPEED) forwardSpeed = MAX_FORWARD_SPEED;

      // --- Ciclo dia-noite ---
      const now = Date.now();
      const t = ((now - dayNightStart) % dayNightDuration) / dayNightDuration;
      const phase = t < 0.5 ? t * 2 : (1 - t) * 2; // 0 a 1 a 0

      // Troca a textura do sol/lua conforme o ciclo
      if (phase < 0.5) {
        // Dia: mostra o sol
        if (sun.material.map !== sunTexture) {
          sun.material.map = sunTexture;
          sun.material.needsUpdate = true;
        }
        // Make the sun emit more light during the day
        sunPointLight.intensity = 1.5;
        sunLight.intensity = 0.55 * (1 - phase * 2); // Brightest at noon (phase = 0)
      } else {
        // Noite: mostra a lua
        if (sun.material.map !== moonTexture) {
          sun.material.map = moonTexture;
          sun.material.needsUpdate = true;
        }
        // Dim the sun light at night
        sunPointLight.intensity = 0.1;
        sunLight.intensity = 0;
      }

      if (playerModel) {
        playerModel.position.copy(cube.position); // Sincroniza a posi√ß√£o da fada com o cubo
        playerModel.rotation.copy(cube.rotation); // Sincroniza a rota√ß√£o do cubo com o modelo
        playerModel.rotation.z = gravityInverted ? Math.PI : 0; // Corrige a rota√ß√£o ao apanhar o power-up
        if (isFlying) {
          playerModel.position.y += 2.1; // Ajusta a altura em 1 unidade para cima durante o voo
        } else if (cube.isOnGround) {
          playerModel.position.y = -2.7; // Posi√ß√£o normal quando n√£o est√° voando
        }
        if (mixer) {
          mixer.update(0.016); // Atualiza cerca de 60fps
        }
      }

      // Update sky and fog colors
      skyMaterial.uniforms.topColor.value.lerpColors(dayColors.skyTop, nightColors.skyTop, phase);
      skyMaterial.uniforms.bottomColor.value.lerpColors(dayColors.skyBottom, nightColors.skyBottom, phase);
      scene.fog.color.lerpColors(dayColors.fog, nightColors.fog, phase);
      sun.material.color.lerpColors(dayColors.sun, nightColors.sun, phase);
      ambientLight.intensity = 0.45;

      // Update the position of the point light to follow the sun
      sunPointLight.position.copy(sun.position);

      fireflies.children.forEach((f, i) => {
        f.position.y += Math.sin(Date.now() * 0.002 + i) * 0.003;
        f.material.opacity = 0.5 + 0.5 * Math.sin(Date.now() * 0.005 + i);
        f.position.z += forwardSpeed;
        if (f.position.z > runwayLength / 2) f.position.z -= runwayLength;
      });

      cube.velocity.x = 0;
      if (keys.a || keys.arrowleft) cube.velocity.x = -0.08;
      if (keys.d || keys.arrowright) cube.velocity.x = 0.08;
      cube.update(ground);

      // Mant√©m o cubo sempre na mesma posi√ß√£o z
      cube.position.z = 0;

      // Move e recicla todas as pe√ßas da estrada
      carpets.forEach(carpet => {
        carpet.position.z += forwardSpeed;
        if (carpet.position.z > runwayLength / 2)
          carpet.position.z -= runwayLength;
      });

      centerLines.forEach(centerLine => {
        centerLine.position.z += forwardSpeed;
        if (centerLine.position.z > runwayLength / 2)
          centerLine.position.z -= runwayLength;
      });

      lightGroup.children.forEach(light => {
        light.position.z += forwardSpeed;
        if (light.position.z > runwayLength / 2) light.position.z -= runwayLength;
      });

      trees.forEach(tree => {
        tree.position.z += forwardSpeed;
        if (tree.position.z > runwayLength / 2)
          tree.position.z -= runwayLength;
      });

      // --- Atualiza√ß√£o dos inimigos e moedas ---
      enemies.forEach((enemy, i) => {
        if (enemy.userData && enemy.userData.type === 'coin') {
          enemy.position.z += forwardSpeed;

          // Ensure rotation works correctly
          enemy.rotation.y += 0.15;

          // Create bounding boxes for collision detection
          const coinBox = new THREE.Box3().setFromObject(enemy);
          const playerBox = new THREE.Box3().setFromCenterAndSize(
            cube.position,
            new THREE.Vector3(cube.width, cube.height, cube.depth)
          );

          if (coinBox.intersectsBox(playerBox)) {
            score += 5;
            updateScore();

            // Remove from scene
            scene.remove(enemy);

            // Instead of trying to return to pool now, just remove
            enemies.splice(i, 1);

            // Play sound effect
            coinSound.currentTime = 0;
            coinSound.play();
          }
        } else if (enemy.userData && enemy.userData.type === 'flyPower') {
          enemy.position.z += forwardSpeed;
          // Colis√£o com o cubo verde ativa o voo
          const powerBox = new THREE.Box3().setFromObject(enemy);
          const playerBox = new THREE.Box3().setFromCenterAndSize(
            cube.position,
            new THREE.Vector3(cube.width, cube.height, cube.depth)
          );
          // No trecho onde o jogador coleta o power up, por volta da linha 954
          if (powerBox.intersectsBox(playerBox) && !isFlying) {
            gravityInverted = !gravityInverted;
            cube.gravity *= -1;
            cube.velocity.y = gravityInverted ? 0.12 : -0.12;
            isFlying = true;
            flyStartTime = Date.now();
            flyingCoinsGenerated = false; // Permite gerar moedas voadoras no pr√≥ximo voo

            wingSound.currentTime = 0; // Reset the sound to start
            wingSound.play();

            // Ativa a anima√ß√£o de nata√ß√£o
            if (mixer && swimAction && idleAction) {
              idleAction.fadeOut(0.5); // Fade-out da anima√ß√£o padr√£o
              swimAction.reset().fadeIn(0.5).play(); // Inicia a anima√ß√£o de nata√ß√£o com fade-in
            }

            // desativar anima√ß√£o de nata√ß√£o ap√≥s 5 segundos
            setTimeout(() => {
              if (mixer && swimAction) {
                swimAction.fadeOut(0.5); // Fade-out da anima√ß√£o de nata√ß√£o
                idleAction.reset().fadeIn(0.5).play(); // Volta para a anima√ß√£o padr√£o
              }
            }, 5000);

            scene.remove(enemy);
            enemies.splice(i, 1);
          }
          // Opcional: anima√ß√£o do power up (ex: rodar)
          enemy.rotation.y += 0.05;
        } else if (enemy.userData && enemy.userData.type === 'bomb') {
          // Movimento da bomba (mais lento que as moedas)
          enemy.position.z += forwardSpeed;

          // Adiciona rota√ß√£o para a bomba (opcional)
          enemy.rotation.y += 0.03;

          // Verifica colis√£o com o jogador
          const bombBox = new THREE.Box3().setFromObject(enemy);
          const playerBox = new THREE.Box3().setFromCenterAndSize(
            cube.position,
            new THREE.Vector3(cube.width, cube.height, cube.depth)
          );

          if (bombBox.intersectsBox(playerBox)) {
            lives--;
            updateLives();

            bombSound.currentTime = 0; // Reset the sound to start
            bombSound.play();

            // Add damage animation here
            if (playerModel) {
              // Play take_damage animation if available
              if (mixer && takeDamage && idleAction) {
                // Fade out current animations
                idleAction.fadeOut(0.2);
                //if (isFlying && swimAction) swimAction.fadeOut(0.2);

                // Play damage animation
                takeDamage.reset().fadeIn(0.2).play();

                // Return to previous animation after damage animation completes
                setTimeout(() => {
                  takeDamage.fadeOut(0.3);
                  if (isFlying && swimAction) {
                    swimAction.reset().fadeIn(0.3).play();
                  } else {
                    idleAction.reset().fadeIn(0.3).play();
                  }
                }, 500); // Animation duration in ms
              }

              // Also keep the visual damage effect (flash red + shake)
              playerModel.traverse(child => {
                if (child.isMesh && child.material) {
                  // Save original color
                  child.userData.originalColor = child.material.color.clone();
                  // Set to red
                  child.material.color.set('#ff0000');
                }
              });

              // Add slight shake animation
              const originalPosition = playerModel.position.clone();
              const shakeIntensity = 0.05;

              // Animation timeline for damage effect
              const shakeDuration = 500; // ms
              const startTime = Date.now();

              function animateDamage() {
                const elapsed = Date.now() - startTime;
                if (elapsed < shakeDuration) {
                  // Apply shake effect
                  playerModel.position.x = originalPosition.x + (Math.random() - 0.5) * shakeIntensity;
                  playerModel.position.y = originalPosition.y + (Math.random() - 0.5) * shakeIntensity;
                  requestAnimationFrame(animateDamage);
                } else {
                  // Reset position and color when done
                  playerModel.position.copy(originalPosition);
                  playerModel.traverse(child => {
                    if (child.isMesh && child.material && child.userData.originalColor) {
                      child.material.color.copy(child.userData.originalColor);
                    }
                  });
                }
              }
              animateDamage();
            }

            if (lives <= 0) {
              showGameOver();
            }
            scene.remove(enemy);
            enemies.splice(i, 1);
          }
        } else if (enemy instanceof Box) {
          // Reduz a velocidade dos cubos vermelhos para metade
          if (enemy.material.color.equals(new THREE.Color('red'))) {
            enemy.position.z += forwardSpeed * 0.125;
          } else {
            enemy.position.z += forwardSpeed;
          }
          enemy.update(ground);
          if (boxCollision({ box1: cube, box2: enemy })) {
            if (enemy.material.color.equals(new THREE.Color('red'))) {
              lives--;
              updateLives();
              if (lives <= 0) {
                showGameOver();
              }
            }
            scene.remove(enemy);
            enemies.splice(i, 1);
          }
        }
      });

      // Substitua o bloco do sistema de c√¢maras com este:
      // --------- SISTEMA DE C√ÇMARAS ---------
      // 1¬™ pessoa
      camera1st.position.set(
        cube.position.x,
        cube.position.y + 0.4,
        cube.position.z + 0.2
      );
      camera1st.rotation.set(0, 0, 0); // Reset de rota√ß√£o
      camera1st.lookAt(
        cube.position.x,
        cube.position.y + 0.4,
        cube.position.z - 1
      );

      // 3¬™ pessoa normal
      camera3rd.position.set(
        cube.position.x,
        cube.position.y + 2,
        cube.position.z + 3.5
      );
      camera3rd.rotation.set(0, 0, 0); // Reset de rota√ß√£o
      camera3rd.lookAt(cube.position.x, cube.position.y + 0.5, cube.position.z);

      // 3¬™ pessoa afastada
      cameraFar.position.set(
        cube.position.x,
        cube.position.y + 5,
        cube.position.z + 8
      );
      cameraFar.rotation.set(0, 0, 0); // Reset de rota√ß√£o
      cameraFar.lookAt(cube.position.x, cube.position.y + 0.5, cube.position.z);

      // Renderiza com a c√¢mara ativa
      let activeCamera;
      if (cameraMode === 0) activeCamera = camera1st;
      else if (cameraMode === 1) activeCamera = camera3rd;
      else activeCamera = cameraFar;

      renderer.render(scene, activeCamera);

      spawnTimer++;
      if (spawnTimer >= spawnCooldown) {
        spawnTimer = 0;
        if (spawnCooldown > 10) spawnCooldown -= 1;

        const spawnRoll = Math.random();
        const lateralLimit = LIMITE_ESTRADA - cube.width / 2;

        // 55% coins, 40% bombs, 5% power-ups
        if (spawnRoll < 0.55) {
          // Spawn a coin
          const coinX = (Math.random() - 0.5) * (lateralLimit * 2);
          const coinY = -2.3;
          spawnCoin(coinX, coinY, -30);

          // Add a second coin nearby with 30% chance
          if (Math.random() < 0.3) {
            const coinX2 = coinX + (Math.random() - 0.5) * 1.5;
            spawnCoin(coinX2, coinY, -30 - Math.random() * 2);
          }
        }
        else if (spawnRoll < 0.95) {
          // Spawn a bomb (40% chance)
          const bombX = (Math.random() - 0.5) * (lateralLimit * 2);
          spawnBomb(bombX, 0, -30);

          // Add a coin on the side of the bomb with 70% chance
          if (Math.random() < 0.7) {
            const coinY = -2.3;
            const offset = 1.5 + Math.random() * 0.5;
            let coinX = bombX + (Math.random() < 0.5 ? -offset : offset);
            if (coinX < -lateralLimit) coinX = -lateralLimit + 0.5;
            if (coinX > lateralLimit) coinX = lateralLimit - 0.5;
            spawnCoin(coinX, coinY, -30);
          }
        }
        else {
          // Spawn a power up (5% chance)
          const powerX = (Math.random() - 0.5) * (lateralLimit * 2);
          const powerY = -2.3;
          spawnPowerUp(powerX, powerY, -30);

          // Add coins near power-ups to create rewarding paths
          if (Math.random() < 0.8) {
            const offset = 1.8;
            const coinX = powerX + (Math.random() < 0.5 ? -offset : offset);
            spawnCoin(coinX, powerY, -30);
          }
        }
      }

      // Limita o cubo verde √† estrada
      const limite = LIMITE_ESTRADA - cube.width / 2;
      if (cube.position.x < -limite) cube.position.x = -limite;
      if (cube.position.x > limite) cube.position.x = limite;

      // Gera moedas voadoras apenas uma vez por voo, 1 segundo ap√≥s in√≠cio
      if (isFlying && !flyingCoinsGenerated && Date.now() - flyStartTime > 1000) {
        flyingCoinsGenerated = true;
        flyingCoins = [];

        // Par√¢metros de tempo
        const delay = 1; // ms (1 segundo ap√≥s in√≠cio)
        const endBuffer = 500; // ms (meio segundo antes do fim)
        const availableTime = FLY_DURATION - delay; // tempo √∫til para apanhar moedas

        // Calcula o n√∫mero de moedas proporcional √† velocidade (m√≠nimo 10, m√°ximo 20)
        // Quanto mais r√°pido, mais moedas
        let coinsToGenerate = Math.round(
          10 + 10 * ((forwardSpeed - BASE_FORWARD_SPEED)) // (MAX_FORWARD_SPEED - BASE_FORWARD_SPEED))
        );
        coinsToGenerate = Math.max(10, Math.min(20, coinsToGenerate));

        // Dist√¢ncia total do spawn das moedas
        const startZ = -30 + forwardSpeed * 60 * (delay / 1000);
        const endZ = -30 + forwardSpeed * 60 * ((delay + availableTime) / 1000);
        const totalDistance = endZ - startZ;

        // Espa√ßamento entre moedas
        const distanceBetweenCoins = totalDistance / (coinsToGenerate - 1);

        for (let i = 0; i < coinsToGenerate; i++) {
          const coinZ = startZ + i * distanceBetweenCoins;
          if (coinZ > endZ) break;

          // X aleat√≥rio dentro do limite lateral
          const coinX = (Math.random() - 0.5) * (LIMITE_ESTRADA - cube.width / 2) * 2;
          // Altura fixa: igual √† do cubo verde durante o voo
          const coinY = cube.position.y;

          spawnCoin(coinX, coinY, coinZ);
          // Se quiseres garantir que n√£o h√° sobreposi√ß√£o com asas, a fun√ß√£o spawnCoin j√° faz isso
          // flyingCoins.push(coin); // Se quiseres guardar refer√™ncia
        }
      }

      // Quando o voo termina, limpe o estado:
      if (!isFlying) {
        flyingCoinsGenerated = false;
        flyingCoins = [];
      }
      // Movimento do sol e da lua no horizonte
      const sunHeight = 15; // Altura m√°xima no c√©u
      const sunRadius = 15; // Raio da trajet√≥ria no horizonte

      if (phase < 0.5) {
        // Dia: movimento do sol
        const angle = Math.PI * phase; // √Çngulo do sol (0 a œÄ)
        sun.position.set(
          Math.cos(angle) * sunRadius, // Movimento horizontal
          Math.sin(angle) * sunHeight, // Movimento vertical
          -10 // Mant√©m a posi√ß√£o Z
        );
        // Move the directional light to follow the sun
        sunLight.position.set(
          sun.position.x,
          sun.position.y + 10,
          sun.position.z
        );
      } else {
        // Noite: movimento da lua
        const angle = Math.PI * (phase - 0.5); // √Çngulo da lua (0 a œÄ)
        sun.position.set(
          Math.cos(angle) * sunRadius, // Movimento horizontal
          Math.sin(angle) * sunHeight, // Movimento vertical
          -10 // Mant√©m a posi√ß√£o Z
        );
      }
    }

    // Menu scene variables
    let menuScene, menuCamera, menuRenderer;
    let menuFairy = null;
    let menuMixer = null;
    let menuIdleAction = null;
    let menuFloatPhase = 0;
    let menuTrees = [];
    let menuFireflies;

    // Setup menu scene
    function setupMenuScene() {
      // Create separate renderer for menu
      menuRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      menuRenderer.setSize(window.innerWidth, window.innerHeight);
      menuRenderer.shadowMap.enabled = true;
      menuRenderer.domElement.style.position = 'absolute';
      menuRenderer.domElement.style.top = '0';
      menuRenderer.domElement.style.left = '0';
      menuRenderer.domElement.style.zIndex = '99'; // Below the menu container
      document.body.insertBefore(menuRenderer.domElement, document.body.firstChild);

      // Create menu scene
      menuScene = new THREE.Scene();

      // Setup camera
      menuCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      menuCamera.position.set(0, 0, 5);
      menuCamera.lookAt(0, 0, 0);

      // Add lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      menuScene.add(ambientLight);

      const dirLight = new THREE.DirectionalLight(0xffffcc, 0.7);
      dirLight.position.set(5, 10, 7);
      // Also fix the menu scene shadows (around line 2039 in setupMenuScene)
      // Modify the dirLight in the menu scene:
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 2048;
      dirLight.shadow.mapSize.height = 2048;
      dirLight.shadow.camera.near = 0.1;
      dirLight.shadow.camera.far = 100;
      dirLight.shadow.camera.left = -20;
      dirLight.shadow.camera.right = 20;
      dirLight.shadow.camera.top = 20;
      dirLight.shadow.camera.bottom = -5;
      dirLight.shadow.bias = -0.0005;
      menuScene.add(dirLight);


      // Create enchanted sky background
      const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
      const skyMaterial = new THREE.ShaderMaterial({
        uniforms: {
          topColor: { value: new THREE.Color('#8624e1') },
          bottomColor: { value: new THREE.Color('#ff69b4') },
        },
        vertexShader: `
      varying vec3 vWorldPosition;
      void main() {
        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
        vWorldPosition = worldPosition.xyz;
        gl_Position = projectionMatrix * viewMatrix * worldPosition;
      }
    `,
        fragmentShader: `
      uniform vec3 topColor;
      uniform vec3 bottomColor;
      varying vec3 vWorldPosition;
      void main() {
        float height = normalize(vWorldPosition).y;
        gl_FragColor = vec4(mix(bottomColor, topColor, max(height, 0.0)), 1.0);
      }
    `,
        side: THREE.BackSide,
      });
      const sky = new THREE.Mesh(skyGeometry, skyMaterial);
      menuScene.add(sky);

      // Add ground
      const ground = new THREE.Mesh(
        new THREE.CircleGeometry(20, 64),
        new THREE.MeshStandardMaterial({
          color: '#3a8f5a',
          side: THREE.DoubleSide
        })
      );
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -2.5;
      ground.receiveShadow = true;
      menuScene.add(ground);

      // Add fireflies for magical effect
      menuFireflies = new THREE.Group();
      const fireflyMaterial = new THREE.SpriteMaterial({
        color: '#ffffaa',
        transparent: true,
        opacity: 0.8
      });

      for (let i = 0; i < 100; i++) {
        const sprite = new THREE.Sprite(fireflyMaterial.clone());
        sprite.scale.set(0.2, 0.2, 0.2);
        const angle = Math.random() * Math.PI * 2;
        const radius = 2 + Math.random() * 10;
        sprite.position.set(
          Math.cos(angle) * radius,
          Math.random() * 6 - 1,
          Math.sin(angle) * radius
        );
        sprite.userData = {
          velocity: new THREE.Vector3(
            (Math.random() - 0.5) * 0.02,
            (Math.random() - 0.5) * 0.02,
            (Math.random() - 0.5) * 0.02
          ),
          pulse: Math.random() * Math.PI
        };
        menuFireflies.add(sprite);
      }
      menuScene.add(menuFireflies);

      // Add enchanted trees
      function addMenuTrees(count = 15) {
        const menuEnvironmentalObjects = [];

        function isMenuPositionOccupied(x, z, minDistance = 3.0) {
          return menuEnvironmentalObjects.some(obj => {
            const dx = obj.x - x;
            const dz = obj.z - z;
            return Math.sqrt(dx * dx + dz * dz) < minDistance;
          });
        }

        let treesAdded = 0;
        let attempts = 0;
        const maxAttempts = count * 3;

        while (treesAdded < count && attempts < maxAttempts) {
          attempts++;

          // Position trees in a circle
          const angle = Math.random() * Math.PI * 2;
          const radius = 6 + Math.random() * 5;
          const x = Math.cos(angle) * radius;
          const z = Math.sin(angle) * radius;

          // Skip if too close to other trees
          if (isMenuPositionOccupied(x, z, 2.5)) {
            continue;
          }

          // Save position
          menuEnvironmentalObjects.push({ x, z });
          treesAdded++;

          const treeHeight = 2 + Math.random() * 1;
          const trunk = new THREE.Mesh(
            new THREE.CylinderGeometry(0.1, 0.12, treeHeight),
            new THREE.MeshStandardMaterial({ map: barkTexture })
          );
          trunk.castShadow = true;
          trunk.receiveShadow = true;

          // Vibrant colors for enchanted forest
          const colors = ['#9370db', '#32cd32', '#4b0082', '#1e90ff'];
          const coneMaterial = new THREE.MeshStandardMaterial({
            color: colors[Math.floor(Math.random() * colors.length)],
            emissive: '#222',
            emissiveIntensity: 0.2
          });

          const cones = [];
          for (let j = 0; j < 3; j++) {
            const cone = new THREE.Mesh(
              new THREE.ConeGeometry(0.6 - j * 0.1, 0.8, 8),
              coneMaterial
            );
            cone.castShadow = true;
            cone.receiveShadow = true;
            cones.push(cone);
          }

          // Position trees in a circle
          const treeAngle = Math.random() * Math.PI * 2;
          const treeRadius = 6 + Math.random() * 5;
          const treeX = Math.cos(treeAngle) * treeRadius;
          const treeZ = Math.sin(treeAngle) * treeRadius;

          const y = -2.5;
          const trunkTopY = y + treeHeight / 2;
          trunk.position.set(treeX, trunkTopY, treeZ);
          menuScene.add(trunk);
          menuTrees.push(trunk);

          cones.forEach((cone, idx) => {
            const heightSoFar = trunkTopY + 0.6 + idx * 0.5;
            cone.position.set(treeX, heightSoFar, treeZ);
            menuScene.add(cone);
            menuTrees.push(cone);
          });
        }
      }

      addMenuTrees();

      // Load fairy model
      const menuFairyLoader = new GLTFLoader();
      menuFairyLoader.load('assets/models/flora_sirenix.glb', (gltf) => {

        menuFairy = gltf.scene;
        menuFairy.scale.set(0.8, 0.8, 0.8);
        menuFairy.position.set(0, -1, 0);

        // Change this line:
        // menuFairy.rotation.y = 0; // Facing camera

        // To this:
        menuFairy.rotation.y = 165 * (Math.PI / 180); // Rotate by 165 degrees

        menuFairy.castShadow = true;
        menuFairy.receiveShadow = true;
        menuScene.add(menuFairy);

        // Animation mixer
        menuMixer = new THREE.AnimationMixer(menuFairy);

        if (gltf.animations && gltf.animations.length > 0) {
          const idleClip = gltf.animations.find(anim =>
            anim.name.toLowerCase().includes("idle")
          );

          if (idleClip) {
            menuIdleAction = menuMixer.clipAction(idleClip);
            menuIdleAction.play();
          }
        }
      });
    }

    // Animate menu scene
    function animateMenu() {
      if (!gameStarted) {
        requestAnimationFrame(animateMenu);

        // Animate fireflies
        menuFireflies.children.forEach((firefly) => {
          // Gentle float movement
          firefly.position.x += firefly.userData.velocity.x;
          firefly.position.y += firefly.userData.velocity.y;
          firefly.position.z += firefly.userData.velocity.z;

          // Pulsing glow
          firefly.userData.pulse += 0.02;
          firefly.material.opacity = 0.5 + 0.5 * Math.sin(firefly.userData.pulse);

          // Boundary check and reverse
          if (Math.abs(firefly.position.x) > 10 ||
            firefly.position.y < -1 || firefly.position.y > 6 ||
            Math.abs(firefly.position.z) > 10) {
            firefly.userData.velocity.multiplyScalar(-1);
          }
        });

        // Animate fairy floating
        if (menuFairy) {
          menuFloatPhase += 0.01;
          menuFairy.position.y = -1 + Math.sin(menuFloatPhase) * 0.1;

          if (menuMixer) {
            menuMixer.update(0.016);
          }
        }

        // Render menu scene
        menuRenderer.render(menuScene, menuCamera);
      }
    }

    // Initialize menu scene
    setupMenuScene();
    animateMenu();

    // Resource management system
    const resourceManager = {
      // Track all disposable resources
      textures: [],
      geometries: [],
      materials: [],

      // Method to register resources for later disposal
      track: function (resource, type) {
        if (type === 'texture' && !this.textures.includes(resource)) {
          this.textures.push(resource);
        } else if (type === 'geometry' && !this.geometries.includes(resource)) {
          this.geometries.push(resource);
        } else if (type === 'material' && !this.materials.includes(resource)) {
          this.materials.push(resource);
        }
      },

      // Method to dispose specific resources
      dispose: function (resource) {
        if (resource.isTexture) {
          resource.dispose();
          const index = this.textures.indexOf(resource);
          if (index !== -1) this.textures.splice(index, 1);
        } else if (resource.isBufferGeometry) {
          resource.dispose();
          const index = this.geometries.indexOf(resource);
          if (index !== -1) this.geometries.splice(index, 1);
        } else if (resource.isMaterial) {
          resource.dispose();
          const index = this.materials.indexOf(resource);
          if (index !== -1) this.materials.splice(index, 1);
        }
      },

      // Method to clean up an object and all its children
      disposeObject: function (object) {
        if (!object) return;

        // First process all children recursively
        if (object.children && object.children.length > 0) {
          // Create a copy of the children array to avoid modification issues during iteration
          const children = [...object.children];
          for (let i = 0; i < children.length; i++) {
            this.disposeObject(children[i]);
          }
        }

        // Then dispose of this object's resources
        if (object.geometry) {
          object.geometry.dispose();
          const geoIndex = this.geometries.indexOf(object.geometry);
          if (geoIndex !== -1) this.geometries.splice(geoIndex, 1);
        }

        if (object.material) {
          if (Array.isArray(object.material)) {
            for (let i = 0; i < object.material.length; i++) {
              this.disposeMaterial(object.material[i]);
            }
          } else {
            this.disposeMaterial(object.material);
          }
        }

        // Remove from parent to completely detach from scene
        if (object.parent) {
          object.parent.remove(object);
        }
      },

      // Helper method to properly dispose materials
      disposeMaterial: function (material) {
        if (!material) return;

        // Dispose textures used by this material
        for (const prop in material) {
          const value = material[prop];
          if (value && value.isTexture) {
            value.dispose();
            const texIndex = this.textures.indexOf(value);
            if (texIndex !== -1) this.textures.splice(texIndex, 1);
          }
        }

        // Dispose the material itself
        material.dispose();
        const matIndex = this.materials.indexOf(material);
        if (matIndex !== -1) this.materials.splice(matIndex, 1);
      },

      // Method to clear all tracked resources
      disposeAll: function () {
        // Dispose all textures
        this.textures.forEach(texture => texture.dispose());
        this.textures = [];

        // Dispose all geometries
        this.geometries.forEach(geometry => geometry.dispose());
        this.geometries = [];

        // Dispose all materials
        this.materials.forEach(material => material.dispose());
        this.materials = [];
      }
    };

    // Improve the texture loading to track resources
    const enhancedTextureLoader = {
      load: function (url) {
        const texture = textureLoader.load(url,
          // Success callback
          function (loadedTexture) {
            resourceManager.track(loadedTexture, 'texture');
          },
          undefined,
          function (err) {
            console.error('Error loading texture:', url, err);
          }
        );
        return texture;
      }
    };

    // Initialize object pools
    const objectPools = {
      coins: [],
      wings: [],
      bombs: [],
      sparkles: [],

      getFromPool: function (type) {
        const pool = this[type];
        if (pool && pool.length > 0) {
          return pool.pop();
        }
        return null;
      },

      returnToPool: function (object, type) {
        if (!object || !this[type]) return;

        // Reset the object state
        object.visible = false;
        if (object.position) object.position.set(0, 0, 0);

        // Add back to pool
        this[type].push(object);
      },

      clearPools: function () {
        // Dispose all objects in pools
        for (const type in this) {
          if (Array.isArray(this[type])) {
            this[type].forEach(obj => {
              resourceManager.disposeObject(obj);
            });
            this[type] = [];
          }
        }
      }
    };
  </script>
</body>

</html>